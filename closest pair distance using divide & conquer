// squared distance
ll dist(const Point &a, const Point &b) {
    ll dx = a.x - b.x;
    ll dy = a.y - b.y;
    return dx*dx + dy*dy;
}

// ---------------------------------------
// Closest Pair Wrapper Function
// ---------------------------------------
ll closestPair(vector<Point> pts) {

    // Sort by x-coordinate
    sort(pts.begin(), pts.end(), [](auto &a, auto &b){
        return a.x < b.x;
    });

    // Inner recursive function
    function<ll(int,int)> solveDC = [&](int L, int R) -> ll {
        if (R - L <= 3) {
            ll d = LLONG_MAX;
            for (int i = L; i <= R; i++)
                for (int j = i+1; j <= R; j++)
                    d = min(d, dist(pts[i], pts[j]));
            sort(pts.begin() + L, pts.begin() + R + 1,
                 [](auto &a, auto &b){ return a.y < b.y; });
            return d;
        }

        int mid = (L + R) / 2;
        ll midx = pts[mid].x;

        ll d = min(solveDC(L, mid), solveDC(mid+1, R));

        // merge by y
        static vector<Point> temp;
        temp.clear();

        merge(pts.begin()+L, pts.begin()+mid+1,
              pts.begin()+mid+1, pts.begin()+R+1,
              back_inserter(temp),
              [](auto &a, auto &b){ return a.y < b.y; });

        copy(temp.begin(), temp.end(), pts.begin()+L);

        // build strip
        vector<Point> strip;
        for (int i = L; i <= R; i++) {
            if ((pts[i].x - midx) * (pts[i].x - midx) < d)
                strip.push_back(pts[i]);
        }

        // check at most 7 neighbors
        for (int i = 0; i < (int)strip.size(); i++) {
            for (int j = i+1; j < (int)strip.size() &&
                 (strip[j].y - strip[i].y)*(strip[j].y - strip[i].y) < d; j++) {
                d = min(d, dist(strip[i], strip[j]));
            }
        }

        return d;
    };

    return solveDC(0, pts.size() - 1);
}
